###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         20/Oct/2021  10:27:37
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\MAX14830.c
#    Command line                 =
#        -f C:\Users\casari\AppData\Local\Temp\2\EW9E2B.tmp
#        (C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\MAX14830.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -D AM_FREERTOS -D
#        AM_DEBUG_PRINTF -D AM_UTIL_FAULTISR_PRINT -lcN
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\bin
#        --diag_suppress Pa050 -o
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 --no_path_in_file_macros -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\third_party\FreeRTOSv10.1.1\Source\include\\
#        -I C:\Tools\Ambiq\AmbiqSuite-R2.5.1\CMSIS\AmbiqMicro\Include\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\third_party\FreeRTOSv10.1.1\Source\portable\IAR\AMapollo2\\
#        -I C:\Tools\Ambiq\AmbiqSuite-R2.5.1\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\devices\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\utils\\ -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\..\src\\
#        -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\..\src\RTOS\\
#        -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\..\src\artemis\\
#        -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\..\src\bsp\\
#        -I C:\Tools\Ambiq\AmbiqSuite-R2.5.1\mcu\apollo3\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\CMSIS\ARM\Include\\ -I
#        $PROJ_DIR\src\RTOS\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\mcu\apollo3\hal\\ -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\app\\ -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\sys\\ -Ol)
#    Locale                       =  C
#    List file                    =
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\bin\MAX14830.lst
#    Object file                  =
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\bin\MAX14830.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf      =  int_specials
#
###############################################################################

C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\MAX14830.c
      1          /**
      2           * @file MAX14830.c
      3           * @author Matt Casari (matthew.casari@noaa.gov)
      4           * @brief 
      5           * @version 0.1
      6           * @date 2021-08-11
      7           * 
      8           * 
      9           */
     10          #include "MAX14830.h"
     11          
     12          //*****************************************************************************
     13          //
     14          // Required built-ins.
     15          //
     16          //*****************************************************************************
     17          #include <stdint.h>
     18          #include <stdbool.h>
     19          #include <string.h>
     20          #include <stdlib.h>
     21          #include <math.h>
     22          #include <assert.h>
     23          #include <stdio.h>
     24          
     25          //*****************************************************************************
     26          //
     27          // Standard AmbiqSuite includes.
     28          //
     29          //*****************************************************************************
     30          #include "am_mcu_apollo.h"
     31          #include "am_bsp.h"
     32          #include "am_util.h"
     33          
     34          //*****************************************************************************
     35          //
     36          // Artemis specific files
     37          //
     38          //*****************************************************************************
     39          #include "artemis_spi.h"
     40          
     41          //*****************************************************************************
     42          //
     43          // FreeRTOS include files.
     44          //
     45          //*****************************************************************************
     46          #include "FreeRTOS.h"
     47          #include "task.h"
     48          #include "event_groups.h"
     49          #include "semphr.h"
     50          
     51          
     52          //*****************************************************************************
     53          //
     54          // Project Files
     55          //
     56          //*****************************************************************************
     57          #include "am_bsp_pins.h"
     58          #include "buffer_c.h"
     59          
     60          //*****************************************************************************
     61          //
     62          //  Register Defines
     63          //
     64          //*****************************************************************************
     65          /** FIFO Data Registers */
     66          #define MAX14830_RHR   ( 0x00 )
     67          #define MAX14830_THR  ( 0x00 )
     68          
     69          /** Interrupt Registers */
     70          #define MAX14830_REG_IRQEN          ( 0x01 )
     71          #define MAX14830_REG_ISR            ( 0x02 )
     72          #define MAX14830_REG_LSRINTEN       ( 0x03 )
     73          #define MAX14830_REG_LSR            ( 0x04 )
     74          #define MAX14830_REG_SPCLCHRINTEN   ( 0x05 )
     75          #define MAX14830_REG_SPCLCHARINT    ( 0x06 )
     76          #define MAX14830_REG_STSINTEN       ( 0x07 )
     77          #define MAX14830_REG_STSINT         ( 0x08 )
     78          
     79          /** UART Mode Registers */
     80          #define MAX14830_REG_MODE1          ( 0x09 )
     81          #define MAX14830_REG_MODE2          ( 0x0A )
     82          #define MAX14830_REG_LCR            ( 0x0B )
     83          #define MAX14830_REG_RXTIMEOUT      ( 0x0C )
     84          #define MAX14830_REG_HDPIXDELAY     ( 0x0D )
     85          #define MAX14830_REG_IRDA           ( 0x0E )
     86          
     87          /** FIFO Control Registers */
     88          #define MAX14830_REG_FLOWLVL        ( 0x0F )
     89          #define MAX14830_REG_FIFOTRGLVL     ( 0x10 )
     90          #define MAX14830_REG_TXFIFOLVL      ( 0x11 )
     91          #define MAX14830_REG_RXFIFOLVL      ( 0x12 )
     92          
     93          /** Flow Control Registers */
     94          #define MAX14830_REG_FLOWCTRL       ( 0x13 )
     95          #define MAX14830_REG_XON1           ( 0x14 )
     96          #define MAX14830_REG_XON2           ( 0x15 )
     97          #define MAX14830_REG_XOFF1          ( 0x16 )
     98          #define MAX14830_REG_XOFF2          ( 0x17 )
     99          
    100          /** GPIO Registers */
    101          #define MAX14830_REG_GPIOCONFIG     ( 0x18 )
    102          #define MAX14830_REG_GPIODATA       ( 0x19 )
    103          
    104          /** Clock Configuration Registers*/
    105          #define MAX14830_REG_PLLCONFIG      ( 0x1A )
    106          #define MAX14830_REG_BRGCONFIG      ( 0x1B )
    107          #define MAX14830_REG_DIVLSB         ( 0x1C )
    108          #define MAX14830_REG_DIVMSB         ( 0x1D )
    109          #define MAX14830_REG_CLKSOURCE      ( 0x1E )
    110          
    111          /** Global Registers */
    112          #define MAX14830_REG_GLOBALRQ       ( 0x1F )
    113          #define MAX14830_REG_GLOBLCOMND     ( 0x1F )
    114          
    115          /** Synchronization Registers */
    116          #define MAX14830_REG_TXSYNCH        ( 0x20 )
    117          #define MAX14830_REG_SYNCHDELAY1    ( 0x21 )
    118          #define MAX14830_REG_SYNCHDELAY2    ( 0x22 )
    119          
    120          /** Timer Registers */
    121          #define MAX14830_REG_TIMER1         ( 0x23 )
    122          #define MAX14830_REG_TIMER2         ( 0x24 )
    123          
    124          /** Revision Register */
    125          #define MAX14830_REG_REVID          ( 0x25 )
    126          
    127          /** IRQEn Register Bits */
    128          #define MAX14830_IRQ_CTSIEN       ( 1u << 7 )
    129          #define MAX14830_IRQ_RFIFOEMTY    ( 1u << 6 )
    130          #define MAX14830_IRQ_TFIFOEMTY    ( 1u << 5 )
    131          #define MAX14830_IRQ_TFIFOTRG     ( 1u << 4 )
    132          #define MAX14830_IRQ_RFIFOTRG     ( 1u << 3 )
    133          #define MAX14830_IRQ_STS          ( 1u << 2 )
    134          #define MAX14830_IRQ_SPCLCHR      ( 1u << 1 )
    135          #define MAX14830_IRQ_LSRERR       ( 1u )
    136          
    137          /** LSRIntEn Register Bits */
    138          #define MAX14830_LSR_INT_NOISEINT     ( 1u << 5 )
    139          #define MAX14830_LSR_INT_RBREAKI      ( 1u << 4 )
    140          #define MAX14830_LSR_INT_FRAMEERR     ( 1u << 3 )
    141          #define MAX14830_LSR_INT_PARITY       ( 1u << 2 )
    142          #define MAX14830_LSR_INT_ROVERR       ( 1u << 1 )
    143          #define MAX14830_LSR_INT_RTIMEOUT     ( 1u )
    144          
    145          /** LSR Register Bits */
    146          #define MAX14830_LSR_CTS              ( 1u << 7 )
    147          #define MAX14830_LSR_RXNOISE          ( 1u << 5 )
    148          #define MAX14830_LSR_RXBREAK          ( 1u << 4 )
    149          #define MAX14830_LSR_FRAMEERR         ( 1u << 3 )
    150          #define MAX14830_LSR_RXPARITY         ( 1u << 2 )
    151          #define MAX14830_LSR_RXOVERRUN        ( 1u << 1 )
    152          #define MAX14830_LSR_RTIMEOUT         ( 1u )
    153          
    154          /** SpclChrIntEn Register Bits */
    155          #define MAX14830_SCI_MLTDRP          ( 1u << 5 )
    156          #define MAX14830_SCI_BREAK           ( 1u << 4 )
    157          #define MAX14830_SCI_XOFF2           ( 1u << 3 )
    158          #define MAX14830_SCI_XOFF1           ( 1u << 2 )
    159          #define MAX14830_SCI_XON2            ( 1u << 1 )
    160          #define MAX14830_SCE_XON1            ( 1u )
    161          
    162          /** STS Register Bits */
    163          #define MAX14830_STS_CLKRDY          ( 1u << 5 )
    164          #define MAX14830_STS_GPI3             ( 1u << 3 )
    165          #define MAX14830_STS_GPI2             ( 1u << 2 )
    166          #define MAX14830_STS_GPI1             ( 1u << 1 )
    167          #define MAX14830_REG_GPI0             ( 1u )
    168          
    169          /** MODE1 Register Bits */
    170          #define MAX14830_MODE1_IRQ_SEL         ( 1u << 7 )
    171          #define MAX14830_MODE1_TRNSCV_CTRL     ( 1u << 4 )
    172          #define MAX14830_MODE1_RTS_HIZ          ( 1u << 3 )
    173          #define MAX14830_MODE1_TX_HIZ           ( 1u << 2 )
    174          #define MAX14830_MODE1_TX_DISABL        ( 1u << 1 )
    175          #define MAX14830_MODE1_RX_DISABL        ( 1u )
    176          
    177          /** MODE2 Register Bits */
    178          #define MAX14830_MODE2_ECHO_SUPRS       ( 1u << 7 )
    179          #define MAX14830_MODE2_MULTI_DROP       ( 1u << 6 )
    180          #define MAX14830_MODE2_LOOPBACK         ( 1u << 5 )
    181          #define MAX14830_MODE2_SPECIAL_CHR      ( 1u << 4 )
    182          #define MAX14830_MODE2_RX_EMTY_INV      ( 1u << 3 )
    183          #define MAX14830_MODE2_RX_TRIG_INV      ( 1u << 2 )
    184          #define MAX14830_MODE2_FIFO_RST         ( 1u << 1 )
    185          #define MAX14830_MODE2_RST              ( 1u )
    186          
    187          /** LCR Register Bits */
    188          #define MAX14830_LCR_RTS                ( 1u << 7 )
    189          #define MAX14830_LCR_TX_BREAK           ( 1u << 6 )
    190          #define MAX14830_LCR_FORCE_PARITY       ( 1u << 5 )
    191          #define MAX14830_LCR_EVEN_PARITY        ( 1u << 4 )
    192          #define MAX14830_LCR_PARITY_EN          ( 1u << 3 )
    193          #define MAX14830_LCR_STOPBITS_1         ( 0u )
    194          #define MAX14830_LCR_STOPBITS_2         ( 1u << 2 )
    195          #define MAX14830_LCR_LENGTH_5           ( 0x00 )
    196          #define MAX14830_LCR_LENGTH_6           ( 0x01 )
    197          #define MAX14830_LCR_LENGTH_7           ( 0x02 )
    198          #define MAX14830_LCR_LENGTH_8           ( 0x03 )
    199          
    200          /** HDplxDelay Register Bits */
    201          #define MAX14830_HDD_SETUP_MASK         ( 0x0F << 4 )
    202          #define MAX14830_HDD_HOLD_MASK           ( 0x0F )
    203          
    204          /** IrDA Register Bits */
    205          #define MAX14830_IRDA_TX_INV            ( 1u << 5 )
    206          #define MAX14830_IRDA_RX_INV            ( 1u << 4 )
    207          #define MAX14830_IRDA_MIR               ( 1u << 3 )
    208          #define MAX14830_IRDA_RTS_INV           ( 1u << 2 )
    209          #define MAX14830_IRDA_SIR               ( 1u << 1 )
    210          #define MAX14830_IRDA_IRDA_EN           ( 1u )
    211          
    212          /** FlowLvl Register Bits */
    213          #define MAX14830_IRDA_RESUME_MASK       ( 0x0F << 4 )
    214          #define MAX14830_IRDA_HALT_MASK         ( 0x0F )
    215          
    216          /** FIFOTrigLvl Register Bits */
    217          #define MAX14830_IRDA_RX_TRIG           ( 0x0F << 4 )
    218          #define MAX14830_IRDA_TX_TRIG           ( 0x0F )
    219          
    220          /** FlowCtrl Register Bits */
    221          #define MAX14830_FC_TX_XON1_XOFF1       ( 1u << 7 )
    222          #define MAX14830_FC_TX_XON2_XOFF2       ( 1u << 6 )
    223          #define MAX14830_FC_RX_XON1_XOFF1       ( 1u << 5 )
    224          #define MAX14830_FC_RX_XON2_XOFF2       ( 1u << 4 )
    225          #define MAX14830_FC_SW_FLOW_EN          ( 1u << 3 )
    226          #define MAX14830_FC_SW_GPI_ADDR         ( 1u << 2 )
    227          #define MAX14830_FC_AUTO_CTS            ( 1u << 1 )
    228          #define MAX14830_FC_AUTO_RTS            ( 1u )
    229          
    230          /** PLLConfig Register Bits */
    231          #define MAX14830_PLL_PREDIV(x)          ( x & 0x1F )
    232          #define MAX14830_PLL_MULT_6             ( 0u  )
    233          #define MAX14830_PLL_MULT_48            ( 1u << 6 )
    234          #define MAX14830_PLL_MULT_96            ( 1u << 7 )
    235          #define MAX14830_PLL_MULT_144           ( 3u << 6 )
    236          
    237          /** CLKSource Register Bits */
    238          #define MAX14830_CLK_PLL_BYPASS         ( 1u << 3 )
    239          #define MAX14830_CLK_PLL_EN             ( 1u << 2 )
    240          #define MAX14830_CLK_CRYSTAL_EN         ( 1u << 1 )
    241          
    242          /** BRGConfig Register Bits */
    243          #define MAX14830_BRG_CLK_DISABLE        ( 1u << 6 )
    244          #define MAX14830_BRG_4X_MODE            ( 1u << 5 )
    245          #define MAX14830_BRG_2X_MODE            ( 1u << 4 )
    246          
    247          
    248          /** Write Bit */
    249          #define MAX14830_SPI_WRITE_BIT          ( 1u << 7)
    250          
    251          
    252          /** System Settings */
    253          #define MAX14830_XTAL_FREQ              ( 4000000u )
    254          
    255          //
    256          
    257          #define MAX14830_NUM_SERIAL_PORTS       ( 4 )
    258          #define MAX14830_WRITE_TASK_PRIORITY    ( 5 )
    259          #define STACK_SIZE                      ( 128 )
    260          
    261          
    262          //*****************************************************************************
    263          //
    264          // FreeRTOS variables, tasks and semaphores
    265          //
    266          //*****************************************************************************
    267          TaskHandle_t data_read_int_handle;
    268          SemaphoreHandle_t xSpiMutex = NULL;
    269          
    270          //*****************************************************************************
    271          //
    272          // Ambiq IOM static variables
    273          //
    274          //*****************************************************************************
    275          static am_hal_iom_config_t IomConfig = {
    276            .eInterfaceMode       = AM_HAL_IOM_SPI_MODE,
    277            .ui32ClockFreq        = AM_HAL_IOM_500KHZ,
    278            .eSpiMode             = AM_HAL_IOM_SPI_MODE_0,
    279            .pNBTxnBuf            = NULL,
    280            .ui32NBTxnBufLength       = 0
    281          };
    282          
    283          static void *pIomHandle;
    284          const uint8_t CTSIEn        = (1u << 7);
    285          const uint8_t RFifoEmtyIEn  = (1u << 6);
    286          const uint8_t TFifoEmtyIEn  = (1u << 5);
    287          
    288          volatile bool xfer_complete = false;
    289          volatile uint32_t txn_stat = 0;
    290          
    291          #define XFER_DATA_SIZE      ( 64 )
    292          static char xfer_data[XFER_DATA_SIZE];
    293          
    294          
    295          //*****************************************************************************
    296          //
    297          // Circular buffer defines
    298          //
    299          //*****************************************************************************
    300          sCircularBufferC_t txBuf[MAX14830_NUM_SERIAL_PORTS];
    301          sCircularBufferC_t rxBuf[MAX14830_NUM_SERIAL_PORTS];
    302          //
    303          //void xfer_complete_callback(void *pCallbackCtxt, uint32_t transactionStatus){
    304          //    (void)pCallbackCtxt;
    305          //    xfer_complete = true;
    306          //    txn_stat = transactionStatus;
    307          //}
    308          
    309          
    310          //*****************************************************************************
    311          //
    312          // Static Function Prototypes
    313          //
    314          //*****************************************************************************
    315          static void module_MAX14830_Power_On(void);
    316          static void module_MAX14830_Power_Off(void);
    317          static uint32_t module_MAX14830_FastRead(void);
    318          static uint32_t module_MAX14830_Read(
    319                              eMAX18430_ComPort_t port,
    320                              uint32_t ui32Instr,
    321                              uint32_t ui32NumBytes,
    322                              char *pData );
    323          
    324          
    325          static void module_MAX14830_Write(
    326                              eMAX18430_ComPort_t port, 
    327                              uint8_t reg, 
    328                              char *data, 
    329                              uint32_t len
    330                              );
    331          
    332          //*****************************************************************************
    333          //
    334          // Global Functions
    335          //
    336          //*****************************************************************************
    337          /**
    338           * @brief Initialize the MAX14830 IC
    339           * 
    340           */
    341          void MAX14830_init(void)
    342          {
    343            uint32_t status = AM_HAL_STATUS_FAIL;
    344          
    345            /** Initialize the Power Pin */
    346            am_hal_gpio_pinconfig(AM_BSP_GPIO_S2U_ON, g_AM_BSP_GPIO_S2U_ON);
    347            module_MAX14830_Power_Off();
    348            module_MAX14830_Power_On();
    349              
    350            /** Initialize the IRQ Input */
    351            am_hal_gpio_pinconfig(AM_BSP_GPIO_S2U_NIRQ, g_AM_BSP_GPIO_S2U_NIRQ);
    352            
    353            /** Initialize the RESET line */
    354            am_hal_gpio_pinconfig(AM_BSP_GPIO_S2U_NRESET, g_AM_BSP_GPIO_S2U_NRESET);
    355            am_hal_gpio_output_clear(AM_BSP_GPIO_S2U_NRESET);
    356            
    357            
    358            /** Initialize the SPI Configurations */
    359            status = am_hal_iom_initialize(3, &pIomHandle);
    360            printf("INIT: status=%d\n", status);
    361            status = am_hal_iom_power_ctrl(pIomHandle, AM_HAL_SYSCTRL_WAKE, false);
    362            printf("PWRC: status=%d\n", status);
    363            status = am_hal_iom_configure(pIomHandle, &IomConfig);
    364            printf("CONF: status=%d\n", status);
    365            status = am_hal_iom_enable(pIomHandle);
    366            printf("ENAB: status=%d\n", status);
    367            /** Initialie the SPI - MOSI */
    368            status = am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_MOSI, g_AM_BSP_GPIO_IOM3_MOSI);
    369          //  printf("MOSI: status=%d\n", status);
    370            /** Initialie the SPI - MISO */
    371            status = am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_MISO, g_AM_BSP_GPIO_IOM3_MISO);
    372          //  printf("MISO: status=%d\n", status);
    373            /** Initialie the SPI - SCLK */
    374            status = am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SCK, g_AM_BSP_GPIO_IOM3_SCK);
    375          //  printf("SCK : status=%d\n", status);
    376            /** Initialize the Chip Select */
    377            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_CS, g_AM_BSP_GPIO_IOM3_CS);
    378            
    379            /** Clear the IOM register-access interrupts */
    380            am_hal_iom_interrupt_clear(pIomHandle, AM_HAL_IOM_INT_ALL);
    381            am_hal_iom_interrupt_enable(pIomHandle, AM_HAL_IOM_INT_ERR);
    382            
    383            /** Set the NVIC for the IO Master */
    384          //  NVIC_EnableIRQ(IOMSTR3_IRQn);
    385          
    386            /** Set the MAX14830 Clock Source to enable Crystal */
    387            char temp = MAX14830_CLK_CRYSTAL_EN;
    388          //  module_MAX14830_Write(MAX14830_COM_PORT0, MAX14830_REG_CLKSOURCE, &temp, 1);
    389          
    390            /** Start the Read Task */
    391          //  MAX14830_disable(MAX14830_COM_PORT0);
    392          }
    393          
    394          /**
    395           * @brief Enable the MAX14830 Port
    396           * 
    397           * @param port Port to enable
    398           */
    399          void MAX14830_enable(eMAX18430_ComPort_t port)
    400          {
    401            /** If the device is off, turn it on */
    402            uint32_t state = 0;
    403            am_hal_gpio_state_read(AM_BSP_GPIO_S2U_ON, AM_HAL_GPIO_OUTPUT_READ, &state);
    404            if(state == 1)
    405            {
    406              module_MAX14830_Power_On();
    407              am_hal_iom_power_ctrl(pIomHandle, AM_HAL_SYSCTRL_WAKE, false);
    408            }
    409          
    410            /** Enable the Port Clock */
    411            char reg = 0;
    412            module_MAX14830_Read(port, MAX14830_REG_BRGCONFIG, 1, &reg);
    413            reg &= MAX14830_BRG_CLK_DISABLE;
    414            module_MAX14830_Write(port, MAX14830_REG_BRGCONFIG, &reg, 1);
    415          
    416            /** Restart the Read Task if currently suspended */
    417            switch(eTaskGetState(data_read_int_handle))
    418            {
    419              case eReady:
    420                break;
    421              case eRunning:
    422              case eBlocked:
    423                break;
    424              case eSuspended:
    425                vTaskResume(data_read_int_handle);
    426                break;
    427              case eDeleted:
    428                break;
    429              default:
    430                break;
    431            }
    432            vTaskResume(data_read_int_handle);
    433          
    434          }
    435          
    436          void MAX14830_enable_direct(eMAX18430_ComPort_t port)
    437          {
    438            /** If the device is off, turn it on */
    439            uint32_t state = 0;
    440            am_hal_gpio_state_read(AM_BSP_GPIO_S2U_ON, AM_HAL_GPIO_OUTPUT_READ, &state);
    441            if(state == 1)
    442            {
    443              module_MAX14830_Power_On();
    444              am_hal_iom_power_ctrl(pIomHandle, AM_HAL_SYSCTRL_WAKE, false);
    445            }
    446          
    447            /** Enable the Port Clock */
    448            char reg = 0;
    449            module_MAX14830_Read(port, MAX14830_REG_BRGCONFIG, 1, &reg);
    450            reg &= MAX14830_BRG_CLK_DISABLE;
    451            module_MAX14830_Write(port, MAX14830_REG_BRGCONFIG, &reg, 1);
    452          
    453          
    454          }
    455          
    456          /**
    457           * @brief Disable selected MAX14830 Port
    458           * 
    459           * @param port Port to disable
    460           */
    461          void MAX14830_disable(eMAX18430_ComPort_t port)
    462          {
    463            /** Disable the Port Clock */
    464            char reg = 0;
    465            module_MAX14830_Read(port, MAX14830_REG_BRGCONFIG, 1, &reg);
    466            reg |= MAX14830_BRG_CLK_DISABLE;
    467            module_MAX14830_Write(port, MAX14830_REG_BRGCONFIG, &reg, 1);
    468          
    469            /** Check to see if all ports are inactive */
    470            uint8_t cnt = 0;
    471            for(uint8_t i=0; i<4; i++)
    472            {
    473              reg = 0;
    474              module_MAX14830_Read(port, MAX14830_REG_BRGCONFIG, 1, &reg);
    475              if( (reg & MAX14830_BRG_CLK_DISABLE) > 0)
    476              {
    477                cnt++;
    478              }
    479            }
    480          
    481            /** If all the ports are deactivated, shut down the power for lower power ops */
    482            if(cnt ==  MAX14830_NUM_SERIAL_PORTS)
    483            {
    484              am_hal_iom_power_ctrl(pIomHandle, AM_HAL_SYSCTRL_DEEPSLEEP, false);
    485          //    am_hal_gpio_output_set(AM_BSP_GPIO_S2U_ON); //, AM_HAL_SYSCTRL_DEEPSLEEP, false);
    486              module_MAX14830_Power_Off();
    487            }
    488          
    489          }
    490          
    491          /**
    492           * @brief Task for RTOS Read Task
    493           * 
    494           * @param pvParameters 
    495           */
    496          void MAX14830_Interrupt_Task(void *pvParameters)
    497          {   
    498              char data[256];
    499              char *pData = &data[0];
    500          
    501              /** Fast read to the IRQ location */
    502              while( xSemaphoreTake(xSpiMutex, pdMS_TO_TICKS( 500UL )) != pdPASS);
    503              uint32_t irq = module_MAX14830_FastRead();
    504              xSemaphoreGive(xSpiMutex);
    505              
    506          
    507              /** Walk through IRQs to find out which channels has data */
    508              for(uint8_t i=0; i<4; i++)
    509              {
    510                if(irq | (1u<<i))
    511                {
    512                  /** Read the number of words in the FIFO (RxFIFOLvl) register */
    513                  uint32_t len=0;
    514                  while( xSemaphoreTake(xSpiMutex, pdMS_TO_TICKS( 500UL )) != pdPASS);
    515                  module_MAX14830_Read((eMAX18430_ComPort_t)i, MAX14830_RHR, len, pData);
    516                  xSemaphoreGive(xSpiMutex);
    517          
    518                  /** Push the data into a circular buffer */
    519                  for(uint16_t idx=0; idx<256; idx++)
    520                  {
    521                    BufferC_putc(&rxBuf[i], *pData++);
    522                  }
    523                }
    524              }
    525          }
    526          
    527          /**
    528           * @brief RTOS Read Task
    529           * 
    530           * @param pvParameters 
    531           */
    532          void module_MAX14830_Write_Task(void  *pvParameters)
    533          {
    534          
    535            eMAX18430_ComPort_t port = (eMAX18430_ComPort_t) pvParameters;
    536            char data = 0;
    537          
    538            sCircularBufferC_t *pBuf = &txBuf[(uint8_t)port];
    539          
    540            while( xSemaphoreTake(xSpiMutex, pdMS_TO_TICKS( 500UL )) != pdPASS);
    541            while(BufferC_Get_Size(pBuf))
    542            {
    543              BufferC_getc(pBuf, &data);
    544              module_MAX14830_Write(port, MAX14830_THR, &data, 1);
    545            }
    546            xSemaphoreGive(xSpiMutex);
    547            vTaskDelete(NULL);
    548          }
    549          
    550          /**
    551           * D = fRef / (16 * BaudRate)
    552           * DIV = TRUNC(D)
    553           * FRACT, is a 4-bit nibble, which is programmed into BRGConfig[3:0]
    554           * FRACT = ROUND(16 x (D-DIV)).
    555           * 
    556           * 
    557           */
    558          void MAX14830_Set_baudrate(eMAX18430_ComPort_t port, eMAX14830_Baudrate_t baudrate )
    559          {
    560          
    561          //  uint32_t status = AM_HAL_STATUS_FAIL;
    562            
    563          //  module_MAX14830_FastRead();
    564          
    565            float D = MAX14830_XTAL_FREQ / (16 * baudrate );
    566            uint32_t DIV = (uint32_t)trunc(D) ;
    567            uint32_t FRACT = (uint32_t) round(16 * (D - DIV));
    568            FRACT = FRACT & 0x0000000F;
    569            uint32_t DIVMSB = (DIV & 0x00000100) >> 8;
    570            uint32_t DIVLSB = (DIV & 0x000000FF);
    571          
    572            /** Send the BRGConfig */
    573            
    574            module_MAX14830_Write(port, MAX14830_REG_DIVLSB, (char*)&DIVLSB, 1);
    575            module_MAX14830_Write(port, MAX14830_REG_DIVMSB, (char*)&DIVMSB, 1);
    576            module_MAX14830_Write(port, MAX14830_REG_BRGCONFIG, (char*)&FRACT, 1);
    577            
    578          }
    579          
    580          /**
    581           * @brief Write UART RTOS
    582           * 
    583           * @param port Port to write to
    584           * @param data Pointer to data array to write
    585           * @param len Length of data array
    586           */
    587          void MAX14830_UART_Write(eMAX18430_ComPort_t port, char *data, uint32_t len)
    588          {
    589            
    590            char taskDesc[configMAX_TASK_NAME_LEN];
    591            sprintf(taskDesc, "S2U Write CH%u", (uint8_t) port);
    592          
    593            /** Put data into circular buffer */
    594            for(uint8_t i=0; i < len; i++)
    595            {
    596              BufferC_putc(&txBuf[(uint8_t) port], *data++);
    597            }
    598          
    599            /** Ensure the port is enabled */
    600            MAX14830_enable(port);
    601          
    602            /** Create Task */
    603            xTaskCreate( 
    604              module_MAX14830_Write_Task,   
    605              taskDesc, 
    606              STACK_SIZE, 
    607              (void*) port, 
    608              tskIDLE_PRIORITY + MAX14830_WRITE_TASK_PRIORITY, 
    609              NULL);
    610          
    611          }
    612          
    613          /**
    614           * @brief UART Write (non-RTOS)
    615           * 
    616           * @param port Port to write to
    617           * @param data Pointer to data array
    618           * @param len Length of the data array
    619           */
    620          void MAX14830_UART_Write_direct(eMAX18430_ComPort_t port, char *data, uint32_t len)
    621          {
    622            char taskDesc[configMAX_TASK_NAME_LEN];
    623            sprintf(taskDesc, "S2U Write CH%u", (uint8_t) port);
    624          
    625            /** Put data into circular buffer */
    626            for(uint8_t i=0; i < len; i++)
    627            {
    628              BufferC_putc(&txBuf[(uint8_t) port], *data++);
    629            }
    630          
    631            /** Ensure the port is enabled */
    632            MAX14830_enable_direct(port);
    633          
    634            sCircularBufferC_t *pBuf = &txBuf[(uint8_t)port];
    635            char cData;
    636            uint32_t xLen = 0;
    637            while(BufferC_Get_Size(pBuf))
    638            {
    639              xLen = BufferC_gets(pBuf, xfer_data, XFER_DATA_SIZE);
    640              module_MAX14830_Write(port, MAX14830_THR, xfer_data, xLen); 
    641            }
    642          //  while(BufferC_Get_Size(pBuf))
    643          //  {
    644          //    BufferC_getc(pBuf, &cData);
    645          //    module_MAX14830_Write(port, MAX14830_THR, &cData, 1);
    646          //  }
    647          }  
    648          
    649          /**
    650           * @brief UART Read - RTOS
    651           * 
    652           * @param port Port to read from
    653           * @param pData Pointer to data array
    654           * @param max_len Maximum length of data to read
    655           * @return uint32_t Number of characters read
    656           */
    657          uint32_t MAX14830_UART_Read(eMAX18430_ComPort_t port, char *pData, uint32_t max_len)
    658          {
    659            uint32_t len=0;
    660            sCircularBufferC_t *pBuf = &rxBuf[(uint8_t)port];
    661          
    662            while( (BufferC_Get_Size(pBuf) > 0) && (len < max_len) )
    663            {
    664              BufferC_getc(pBuf, pData);
    665              pData++;
    666              len++;
    667            }
    668            return len;
    669          }
    670          
    671          /**
    672           * @brief UART Read (non-RTOS)
    673           * 
    674           * @param port Port to read from
    675           * @param pData Pointer to data array
    676           * @param max_len Maximum length of data to read
    677           * @return uint32_t Number of characters read
    678           */
    679          uint32_t MAX14830_UART_Read_direct(eMAX18430_ComPort_t port, char *pData, uint32_t max_len)
    680          {
    681            
    682            
    683            uint32_t len=0;
    684            sCircularBufferC_t *pBuf = &rxBuf[(uint8_t)port];
    685            
    686            
    687          //  module_MAX14830_FastRead();
    688          
    689            module_MAX14830_Read(MAX14830_COM_PORT0,1, 36, pData);
    690            
    691            printf("%s\n", pData);
    692            
    693          }
    694          
    695          /**
    696           * @brief Find the number of bytes in waiting
    697           * 
    698           * @param port Port to check
    699           * @return uint32_t Number of bytes in waiting
    700           */
    701          uint32_t MAX14830_UART_Read_bytes_waiting(eMAX18430_ComPort_t port)
    702          {
    703            uint32_t len = BufferC_Get_Size(&rxBuf[(uint8_t)port]);
    704            return len;
    705          }
    706          
    707          
    708          
    709          //*****************************************************************************
    710          //
    711          // Static Functions
    712          //
    713          //*****************************************************************************
    714          /**
    715           * @brief Power the MAX14830 ON
    716           * 
    717           */
    718          static void module_MAX14830_Power_On(void)
    719          {
    720            am_hal_iom_enable(&pIomHandle);
    721            am_hal_gpio_output_set(AM_BSP_GPIO_S2U_NRESET);
    722            am_hal_gpio_output_clear(AM_BSP_GPIO_S2U_ON);
    723            
    724          }
    725          
    726          /**
    727           * @brief Power the MAX14830 OFF
    728           * 
    729           */
    730          static void module_MAX14830_Power_Off(void)
    731          {
    732            am_hal_gpio_output_clear(AM_BSP_GPIO_S2U_NRESET);
    733            am_hal_gpio_output_set(AM_BSP_GPIO_S2U_ON);
    734          }
    735          
    736          /**
    737           * @brief MAX14830 Chip Select Set
    738           * 
    739           */
    740          //static void MAX14830_CS_Set(void)
    741          //{
    742          //  am_hal_gpio_output_clear(BSP_GPIO_S2U_SPI_CS);
    743          //}
    744          
    745          /**
    746           * @brief MAX14830 Chip select Clear
    747           * 
    748           */
    749          //static void MAX14830_CS_Clear(void)
    750          //{
    751          //  am_hal_gpio_output_set(BSP_GPIO_S2U_SPI_CS);
    752          //}
    753          
    754          /**
    755           * @brief Fast read
    756           * 
    757           * @return uint32_t 
    758           */
    759          static uint32_t module_MAX14830_FastRead(void)
    760          {
    761            uint32_t write_byte = 0u;
    762            uint32_t read_byte = 0u;
    763            uint32_t status; 
    764            
    765            am_hal_iom_transfer_t xfer;
    766            
    767            xfer.uPeerInfo.ui32SpiChipSelect = 0;
    768            xfer.ui32InstrLen = 0;
    769            xfer.ui32Instr = 0;
    770            xfer.ui32NumBytes = 1;
    771            xfer.eDirection = AM_HAL_IOM_FULLDUPLEX;
    772            xfer.pui32TxBuffer = &write_byte;
    773            xfer.pui32RxBuffer = &read_byte;
    774            xfer.bContinue = false;
    775            xfer.ui8RepeatCount = 0;
    776            xfer.ui8Priority = 1;
    777            xfer.ui32PauseCondition = 0;
    778            xfer.ui32StatusSetClr = 0;
    779          
    780          //  /** Chip Select */
    781          //  MAX14830_CS_Set();
    782            
    783            status = am_hal_iom_spi_blocking_fullduplex(pIomHandle, &xfer);
    784          
    785          //  /** Chip Deselect */
    786          //  MAX14830_CS_Clear();
    787            
    788            printf("FAST READ: status = %ul, rb = %u\n", status, read_byte);
    789            return read_byte;
    790          
    791          }
    792          
    793          
    794          /**
    795           * @brief MAX14830 Read
    796           * 
    797           * @param port  Port to read from
    798           * @param ui32Instr Instruction 
    799           * @param ui32NumBytes Number of Bytes
    800           * @param pData Pointer to data array
    801           * @return uint32_t Number of bytes read
    802           */
    803          static uint32_t
    804          module_MAX14830_Read(
    805             eMAX18430_ComPort_t port,
    806              uint32_t ui32Instr,
    807              uint32_t ui32NumBytes,
    808              char *pData )
    809          {
    810              am_hal_iom_transfer_t Transaction;
    811          
    812          //    /** Chip select */
    813          //    MAX14830_CS_Set();
    814                
    815              //
    816              // Create the transaction.
    817              //
    818              Transaction.ui32InstrLen    = 1;
    819              Transaction.ui32Instr       = ui32Instr;
    820              Transaction.eDirection      = AM_HAL_IOM_RX;
    821              Transaction.ui32NumBytes    = ui32NumBytes;
    822              Transaction.pui32RxBuffer   = (uint32_t*)pData;
    823              Transaction.uPeerInfo.ui32SpiChipSelect = 0;
    824              Transaction.bContinue       = false;
    825              Transaction.ui8RepeatCount  = 0;
    826              Transaction.ui32PauseCondition = 0;
    827              Transaction.ui32StatusSetClr = 0;
    828          
    829              //
    830              // Execute the transction over IOM.
    831              //
    832              if (am_hal_iom_blocking_transfer(pIomHandle, &Transaction))
    833              {
    834                /** Chip Deselect */
    835          //      MAX14830_CS_Clear();
    836                return -1;
    837              }
    838                /** Chip Deselect */
    839          //      MAX14830_CS_Clear();
    840                return 0;
    841              }
    842          
    843          /**
    844           * @brief Write to port
    845           * 
    846           * @param port Port to write to
    847           * @param reg Register to write
    848           * @param data Pointer to data array
    849           * @param len Length of data array
    850           */
    851          static void module_MAX14830_Write(
    852            eMAX18430_ComPort_t port, 
    853            uint8_t reg, 
    854            char *data, 
    855            uint32_t len
    856            )
    857          {
    858            assert(reg <= 0x1F);
    859           
    860          
    861            /** Enable */
    862            module_MAX14830_Power_On();
    863          //  am_hal_iom_enable(&pIomHandle);
    864          
    865            /** Chip Select */
    866          //  MAX14830_CS_Set();
    867            
    868            /** Prep Write Byte */
    869            char write_byte= MAX14830_SPI_WRITE_BIT | reg;
    870            switch(port)
    871            {
    872              case MAX14830_COM_PORT0:
    873                break;
    874              case MAX14830_COM_PORT1:
    875                write_byte|= (1u << 5);
    876                break;
    877              case MAX14830_COM_PORT2:
    878                write_byte|= (1u << 6);
    879                break;
    880              case MAX14830_COM_PORT3:
    881                write_byte|= (3u << 5);
    882                break;
    883              default:
    884                /** Error */
    885                break;
    886            }
    887          
    888            am_hal_iom_transfer_t transfer = 
    889            {
    890              .uPeerInfo = {
    891                .ui32SpiChipSelect    = 0,
    892                .ui32I2CDevAddr       = 0,
    893              },
    894              .ui32InstrLen         = 0,
    895              .ui32Instr            = 0,
    896              .ui32NumBytes         = 1,
    897              .eDirection           = AM_HAL_IOM_TX,
    898              .pui32TxBuffer        = (uint32_t*) &write_byte,
    899              .pui32RxBuffer        = NULL,
    900              .bContinue            = false,
    901              .ui8RepeatCount       = 0,
    902              .ui8Priority          = 1,
    903              .ui32PauseCondition   = 0,
    904              .ui32StatusSetClr     = 0
    905            };
    906          
    907            am_hal_iom_blocking_transfer(pIomHandle, &transfer);
    908           
    909            
    910            transfer.pui32TxBuffer = (uint32_t*) data;
    911            transfer.ui32NumBytes = len;
    912            
    913          
    914            am_hal_iom_blocking_transfer(pIomHandle, &transfer);
    915            
    916            /** After transfer, turn Chip Select off */
    917          //  MAX14830_CS_Clear();
    918            
    919            /** Disable */
    920          //  module_MAX14830_Power_Off();
    921          //  am_hal_iom_disable(&pIomHandle);
    922            
    923          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     280   MAX14830_Interrupt_Task
       280   -> BufferC_putc
       280   -> module_MAX14830_FastRead
       280   -> module_MAX14830_Read
       280   -> xQueueGenericSend
       280   -> xQueueSemaphoreTake
      40   MAX14830_Set_baudrate
        40   -> __aeabi_d2uiz
        40   -> __aeabi_f2d
        40   -> module_MAX14830_Write
        40   -> round
        40   -> trunc
      24   MAX14830_UART_Read
        24   -> BufferC_Get_Size
        24   -> BufferC_getc
       8   MAX14830_UART_Read_bytes_waiting
         8   -> BufferC_Get_Size
       8   MAX14830_UART_Read_direct
         8   -> module_MAX14830_Read
         8   -> printf
      48   MAX14830_UART_Write
        48   -> BufferC_putc
        48   -> MAX14830_enable
        48   -> sprintf
        48   -> xTaskCreate
      40   MAX14830_UART_Write_direct
        40   -> BufferC_Get_Size
        40   -> BufferC_gets
        40   -> BufferC_putc
        40   -> MAX14830_enable_direct
        40   -> module_MAX14830_Write
        40   -> sprintf
      24   MAX14830_disable
        24   -> am_hal_iom_power_ctrl
        24   -> module_MAX14830_Power_Off
        24   -> module_MAX14830_Read
        24   -> module_MAX14830_Write
      16   MAX14830_enable
        16   -> am_hal_gpio_state_read
        16   -> am_hal_iom_power_ctrl
        16   -> eTaskGetState
        16   -> module_MAX14830_Power_On
        16   -> module_MAX14830_Read
        16   -> module_MAX14830_Write
        16   -> vTaskResume
      16   MAX14830_enable_direct
        16   -> am_hal_gpio_state_read
        16   -> am_hal_iom_power_ctrl
        16   -> module_MAX14830_Power_On
        16   -> module_MAX14830_Read
        16   -> module_MAX14830_Write
       8   MAX14830_init
         8   -> am_hal_gpio_pinconfig
         8   -> am_hal_iom_configure
         8   -> am_hal_iom_enable
         8   -> am_hal_iom_initialize
         8   -> am_hal_iom_interrupt_clear
         8   -> am_hal_iom_interrupt_enable
         8   -> am_hal_iom_power_ctrl
         8   -> module_MAX14830_Power_Off
         8   -> module_MAX14830_Power_On
         8   -> printf
      56   module_MAX14830_FastRead
        56   -> am_hal_iom_spi_blocking_fullduplex
        56   -> printf
       0   module_MAX14830_Power_Off
       8   module_MAX14830_Power_On
         8   -> am_hal_iom_enable
      48   module_MAX14830_Read
        48   -> am_hal_iom_blocking_transfer
      64   module_MAX14830_Write
        64   -> __aeabi_assert
        64   -> __aeabi_memcpy4
        64   -> __iar_EmptyStepPoint
        64   -> am_hal_iom_blocking_transfer
        64   -> module_MAX14830_Power_On
      24   module_MAX14830_Write_Task
        24   -> BufferC_Get_Size
        24   -> BufferC_getc
        24   -> module_MAX14830_Write
        24   -> vTaskDelete
        24   -> xQueueGenericSend
        24   -> xQueueSemaphoreTake


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      20  ?_0
      20  ?_1
      20  ?_2
      20  ?_3
      16  ?_4
       4  ?_5
      36  ?_6
      12  ?_7
      12  ?_8
      40  ?_9
       1  CTSIEn
      20  IomConfig
     164  MAX14830_Interrupt_Task
     170  MAX14830_Set_baudrate
      54  MAX14830_UART_Read
      20  MAX14830_UART_Read_bytes_waiting
      40  MAX14830_UART_Read_direct
      94  MAX14830_UART_Write
     128  MAX14830_UART_Write_direct
     122  MAX14830_disable
     138  MAX14830_enable
      90  MAX14830_enable_direct
     208  MAX14830_init
       1  RFifoEmtyIEn
       1  TFifoEmtyIEn
       4  data_read_int_handle
      94  module_MAX14830_FastRead
      18  module_MAX14830_Power_Off
      26  module_MAX14830_Power_On
      70  module_MAX14830_Read
     150  module_MAX14830_Write
     100  module_MAX14830_Write_Task
       4  pIomHandle
   1'064  rxBuf
   1'064  txBuf
       4  txn_stat
       4  xSpiMutex
       1  xfer_complete
      64  xfer_data

 
 2'209 bytes in section .bss
    20 bytes in section .data
   203 bytes in section .rodata
 1'806 bytes in section .text
 
 1'806 bytes of CODE  memory
   203 bytes of CONST memory
 2'229 bytes of DATA  memory

Errors: none
Warnings: 6
