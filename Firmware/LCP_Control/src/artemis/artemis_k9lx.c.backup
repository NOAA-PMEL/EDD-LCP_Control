/**! @file artemis_k9lx.c
 * @brief Maxim SPI-to-UART Converter
 *
 * @author Basharat Martin basharat.martin@noaa.gov
 * @date Feb 23, 2023
 * @version 1.0.0
 *
 * @copyright National Oceanic and Atmospheric Administration
 * @copyright Pacific Marine Environmental Lab
 * @copyright Environmental Development Division
 *
 * @note Controls the Keller 9LXe, circuit board (9L140) Pressure sensor over RS-485
 * 
 *
 * @bug  No known bugs
 *
 **/

/** Simplified COMMS protocol from Keller */
/** 
	Communication Protocol
	D-Line OEM-transmitter samples only on request.
	The idle state is the sleep mode to save power.
	Sequence for data acquisition:
	1. Request measurement
	2 bytes from master
	2. Await the end of conversion (three ways)
	- Simple delay of 8 ms
	- Polling of the �Busy?� flag [5] in the
	status byte (only one byte reading needed)
	- Event triggering by the additional �EOC�
	handshake pin (goes to VDD)
	3. Read out measurement results
	1 byte from master, 3�5 bytes from slave
	4. Interpretation of new data
	P [bar] = P min�P max 16384�49152
	T [�C] = -50�150 �C 384�64384
*/

#include "artemis_max14830.h"

//*****************************************************************************
//
// Required built-ins.
//
//*****************************************************************************
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <stdio.h>

//*****************************************************************************
//
// Standard AmbiqSuite includes.
//
//*****************************************************************************
#include "am_mcu_apollo.h"
#include "am_bsp.h"
#include "am_util.h"
#include "bsp_uart.h"

//*****************************************************************************
//
// Artemis specific files
//
//*****************************************************************************
#include "artemis_k9lx.h"
#include "artemis_debug.h"
#include "artemis_stream.h"

//*****************************************************************************
//
// FreeRTOS include files.
//
//*****************************************************************************
//#include "FreeRTOS.h"
//#include "task.h"
//#include "event_groups.h"
//#include "semphr.h"

//*****************************************************************************
//
// Project Files
//
//*****************************************************************************
#include "am_bsp_pins.h"
#include "buffer_c.h"

//*****************************************************************************
//
//  Macros
//
//*****************************************************************************

#define K9LX_ADDR					0x01	//	0x01 default device address for Modbus
#define K9LX_BUFFER_LENGTH			0x0D	//	13 bytes for 9LXe sensor
#define K9LX_RECV_ERROR				0x80	/*	return with exception error 
												function code 7th bit is high */
/** K9LX Command Bytes */
#define K9LX_READ_REG_CMD			0x03	//	Modbus read command F3:
#define K9LX_WRITE_REG_CMD			0x06	//	Modbus write single register command F6:
#define K9LX_ECHO_CMD				0x08	//	Modbus echo test F8:
#define K9LX_WRITE_REGS_CMD			0x10	//	Modbus write multiple registers command F16:

/*** Modbus Register Map ***/
// 32bit floating point addresses Big-Endian
#define K9LX_FL_CH0					0x0000	//	return calculated value (customer specific)
#define K9LX_FL_P1					0x0002	//	return Pressure of sensor1 in bar (HWord : LWord)
#define K9LX_FL_P2					0x0004	//	return Pressure of sensor2 in bar (HWord : LWord)
#define K9LX_FL_T					0x0006	//	return Temperature in °C (HWord : LWord)
#define K9LX_FL_TOB1				0x0008	//	return Temperature of sensor1 in °C (HWord : LWord)
#define K9LX_FL_TOB2				0x000A	//	return Tempearture of sensor2 in °C (HWord : LWord)

// 32bit floating point addresses, accessing data in one cylce 8 bytes
#define K9LX_FL1_P1					0x0100	//	return Pressure of sensor1 in bar (HWord : LWord)
#define K9LX_FL1_TOB1				0x0102	//	return Temperature of sensor1 in °C (HWord : LWord)
#define K9LX_FL1_P2					0x0104	//	return Pressure of sensor2 in bar (HWord : LWord)
#define K9LX_FL1_TOB2				0x0106	//	return Temperature of sensor2 in °C (HWord : LWord)

// 16bit int addresses 
#define K9LX_INT16_CH0				0x0010	//	return calculated value (customer specific) 1/100 (LSB)
#define K9LX_INT16_P1				0x0011	//	return Pressure of sensor1 in bar (1/100 LSB)
#define K9LX_INT16_P2				0x0012	//	return Pressure of sensor2 in bar (1/100 LSB)
#define K9LX_INT16_T				0x0013	//	return Temperature in °C (1/100 LSB)
#define K9LX_INT16_TOB1				0x0014	//	return Temperature of sensor1 in °C (1/100 LSB)
#define K9LX_INT16_TOB2				0x0015	//	return Tempearture of sensor2 in °C (1/100 LSB)

// 32bit int addresses 
#define K9LX_INT32_CH0				0x0020	//	return calculated value (customer specific) 1/100000 (LSB) 
#define K9LX_INT32_P1				0x0022	//	return Pressure of sensor1 in Pa (1/100000 LSB)
#define K9LX_INT32_P2				0x0024	//	return Pressure of sensor2 in Pa (1/100000 LSB)
#define K9LX_INT32_T				0x0026	//	return Temperature in °C (1/100 LSB)
#define K9LX_INT32_TOB1				0x0028	//	return Temperature of sensor1 in °C (1/100 LSB)
#define K9LX_INT32_TOB2				0x002A	//	return Tempearture of sensor2 in °C (1/100 LSB)

/* Modbus , Device Configuration Registers */
#define K9LX_STATUS					0x020C	//	Read-Only, returns the device status,
#define K9LX_STATUS_CH0_ERROR		(1<<0)	//	0	: 	CH0 error
#define K9LX_STATUS_P1_ERROR		(1<<1)	//	1	:	P1 error
#define K9LX_STATUS_P2_ERROR		(1<<2)	//	2	:	P2 error
#define K9LX_STATUS_T_ERROR			(1<<3)	//	3	:	T error
#define K9LX_STATUS_TOB1_ERROR		(1<<4)	//	4	:	TOB1 error
#define K9LX_STATUS_TOB2_ERROR		(1<<5)	//	5	:	TOB2 error
#define K9LX_STATUS_ERR2_ERROR		(1<<6)	//	6	:	computation error
#define K9LX_STATUS_NSTD_ERROR		(1<<7)	//	7	:	STD error, either in power-up mode or Standard

#define K9LX_SER_NUM_H				0x0202	//	Serial number Higher bits
#define K9LX_SER_NUM_L				0x0203	//	Serial number lower bits
#define K9LX_FIRM_VER0				0x020E	//	Read-Only Firmware version 0 -> Class:Group
#define K9LX_FIRM_VER1				0x020F	//	Read-Only Firmware version 1 -> Year:Week
#define K9LX_P_MODE					0x0209	//	Read-Only : returns type of Sensor and Calibration
											//	Bit 3...0 : P1 = 0:PR(relative), 1:PA(absolute) 15:not available
											//	Bit 7...4 : P2 = 0:PR(relative), 1:PA(absolute) 15:not available

#define K9LX_UART					0x0200	//	R/W : UART settings : Bit 3...0: 0: 9600 1:115200
#define K9LX_UART_96K				(0x0)	//	9600 
#define K9LX_UART_115K				(0x1)	//	115200 

#define K9LX_CFG_P					0x0204	//  R : Active Pressure channel Bit 1:P1, Bit 2:P2
#define K9LX_CFG_P_P1				(1<<1)	//	P1 : bit1
#define K9LX_CFG_P_P2				(1<<2)	//	P2 : bit2

#define K9LX_CFG_T					0x0204	//  R : Active Temperature channel Bit 3:T, Bit 4:TOB1, Bit 5:TOB2
#define K9LX_CFG_T_T				(1<<3)	//	T
#define K9LX_CFG_T_TOB1				(1<<4)	//	TOB1
#define K9LX_CFG_T_TOB2				(1<<5)	//	TOB2

#define CMD_LENGTH					8		//	command size is 8 bytes

//*****************************************************************************
//
//  Register Defines
//
//*****************************************************************************

//*****************************************************************************
//
// Structs, Enums & Typedefs
//
//*****************************************************************************

typedef uint8_t module_buffer_t[K9LX_BUFFER_LENGTH];
typedef struct s_module_t
{
	module_buffer_t txbuffer;
	module_buffer_t rxbuffer;
	struct {
		uint32_t pin;
		am_hal_gpio_pincfg_t *pinConfig;
	} power;

	module_scaling_t scaling;
	module_manufacturer_t manufacturer;

} module_t;

typedef struct s_k9lx_data_t
{
	float pressure;
	float temperature;
} k9lx_data_t;

typedef union {
	struct {
		uint8_t u[4];
	};
	float f;
} u32_to_float_t;

//*****************************************************************************
//
// Static Variables
//
//*****************************************************************************
static module_t module;

//*****************************************************************************
//
// Static Function Prototypes
//
//*****************************************************************************


//*****************************************************************************
//
// Global Functions
//
//*****************************************************************************
static void module_k9lx_read_sensor(k9lx_data_t *data);
static float module_k9lx_convert_pressure(uint32_t u32Pressure);
static float module_k9lx_convert_temperature(uint32_t u32Temp);
static bool module_k9lx_read_status(void);
static uint32_t module_k9lx_read_unique_product_code(void);
static void module_k9lx_convert_memory_manufacturer(uint8_t *data, module_manufacturer_t *m);
static void module_k9lx_convert_memory_pressure( uint8_t *data, 
                                                  module_scaling_t *scaling);
static float module_k9lx_convert_memory_pressure_value(uint8_t *data);
static void module_k9lx_read_memory_pressure(module_scaling_t *scaling);
//static void module_k9lx_read_conf(uint8_t port);
void module_k9lx_read_conf(uint8_t port);
static uint16_t module_k9lx_crc16 (uint8_t *crc_h, uint8_t *crc_l, uint8_t *pData, uint8_t len);
static int8_t module_k9lx_read_reg(uint8_t port, uint16_t reg_add, uint8_t reg_num, uint8_t *pData);
static int8_t module_k9lx_data_integrity (uint8_t *Data, uint8_t len);

void artemis_k9lx_initialize(eMAX18430_ComPort_t port, eMAX14830_Baudrate_t baudRate)
{
	// add uart handler for RS-485
	//assert( (port == BSP_UART_COM0) || (port == BSP_UART_COM1) ||
	//		(port == BSP_UART_COM2) || (port == BSP_UART_COM3) );

	eMAX14830_Baudrate_t br = baudRate;

	module.power.pinConfig = (am_hal_gpio_pincfg_t*)&g_AM_BSP_GPIO_COM3_POWER_PIN;
	module.power.pin = AM_BSP_GPIO_COM3_POWER_PIN;

	/** Initialize the COM Port Power Pin */
	ARTEMIS_DEBUG_HALSTATUS(am_hal_gpio_pinconfig(module.power.pin, *module.power.pinConfig));

	/** Turn K-9LX On */
	artemis_k9lx_power_off();
	artemis_k9lx_power_on();

	/* set max port and baudrate */ 
	artemis_max14830_Set_baudrate(port, br);

	/** Read the module Firmware version, P-Mode, serial number, Active channels */ 
	module_k9lx_read_conf(port);
	//artemis_k9lx_power_off();
}
	
void artemis_k9lx_power_on(void)
{
	am_hal_gpio_output_clear(module.power.pin);
}

void artemis_k9lx_power_off(void)
{
	am_hal_gpio_output_set(module.power.pin);
}

void artemis_k9lx_get_calibration(module_manufacturer_t *manufacturer, module_scaling_t *scaling)
{
	manufacturer = &module.manufacturer;
	scaling = &module.scaling;
}

static uint16_t module_k9lx_crc16 (uint8_t *crc_h, uint8_t *crc_l, uint8_t *pData, uint8_t len){

	uint16_t crc16 = 0xFFFF;
	uint8_t n, m, x;

	m = len;
	x = 0;

	// loop over all bits
	while(m>0){
		crc16 ^= pData[x];
		for(n=0; n<8; n++){
			if(crc16 & 1){
				crc16 >>= 1;
				crc16 ^= 0xA001;
			}
			else {
				crc16 >>= 1;
			}
		}
		m--;
		x++;
	}

	// result
	*crc_h = (crc16 >>8 ) & 0xFF;
	*crc_l = crc16 & 0xFF;

	return crc16 ;
}

void artemis_k9lx_read(float *pressure, float *temperature)
{
	k9lx_data_t data;
	module_k9lx_read_sensor(&data);
	*pressure = data.pressure;
	*temperature = data.temperature;
}

//void artemis_k9lx_read_memory();
//*****************************************************************************
//
// Static Functions
//
//*****************************************************************************
static void module_k9lx_read_sensor(k9lx_data_t *data)
{
	artemis_stream_t rxstream = {0};
	artemis_stream_t txstream = {0};
	artemis_stream_setbuffer(&rxstream, module.rxbuffer, K9LX_BUFFER_LENGTH);
	artemis_stream_setbuffer(&txstream, module.txbuffer, K9LX_BUFFER_LENGTH);

	//artemis_i2c_t *i2c = &module.i2c;

	/** Retrieve Measurement Data */
	//artemis_stream_put(&txstream, K9LX_CMD_REQUEST_MEASURE);


	//artemis_i2c_send(i2c, true, &txstream);
 
	/** @todo Add fail-out mechanism */
	//while(!module_k9lx_read_status());
	//
	//artemis_i2c_receive(i2c, true, &rxstream, 5);


	//module_k9lx_read_with_status(i2c, &rxstream, 5, 10);


	//module_k9lx_read_with_status(&rxstream, 5, 10);

	uint8_t temp;
	/** Skip the status byte */
	//artemis_stream_get(&rxstream, &temp);

	/** Get the 2 bytes of Pressure */
	artemis_stream_get(&rxstream, &temp);
	uint32_t pressure = temp << 8;

	artemis_stream_get(&rxstream, &temp);
	pressure |= temp;
  
	//printf("px = %u, ", pressure);

	/** Get the 2 bytes of Pressure */
	artemis_stream_get(&rxstream, &temp);
	uint32_t temperature = temp << 8;

	artemis_stream_get(&rxstream, &temp);
	temperature |= temp;
	//printf("tx = %u\n", temperature);

	/** Convert the pressure */
	data->pressure = module_k9lx_convert_pressure(pressure);

	/** Convert the temperature */
	data->temperature = module_k9lx_convert_temperature(temperature);
}

static float module_k9lx_convert_pressure(uint32_t u32Pressure)
{
	if(u32Pressure < 16384)
	{
		u32Pressure = 0;
	} 
	else {
		u32Pressure -= 16384;
	}
	//u32Pressure -= 16384;
	//
	//int32 pTemp = (int32_t)u32Pressure;
	//pTemp -= -16384;
	float fPressure =  (float) (u32Pressure);
	fPressure *= module.scaling.diff;
	fPressure /= 32768;
	fPressure += module.scaling.low;

	return fPressure;
}

static float module_k9lx_convert_temperature(uint32_t u32Temp)
{
	u32Temp = u32Temp >> 4;
	float fTemp = (float)(u32Temp);
	fTemp -= 24;
	fTemp *= 0.05;
	fTemp -= 50;

	return fTemp;
}

//static bool module_k9lx_read_status(void)
//{
	//artemis_stream_t rxstream = {0};
	//artemis_stream_setbuffer(&rxstream, module.rxbuffer, K9LX_BUFFER_LENGTH);
	//
	//artemis_i2c_t *i2c = &module.i2c;
	//artemis_i2c_receive(i2c, true, &rxstream, 1);
	//
	//uint8_t data;
	//artemis_stream_get(&rxstream, &data);
	//data = data & K9LX_STATUS_BIT;
	//return data;
//}

static uint32_t module_k9lx_read_unique_product_code(void)
{
	artemis_stream_t rxstream = {0};
	artemis_stream_t txstream = {0};
	artemis_stream_setbuffer(&rxstream, module.rxbuffer, K9LX_BUFFER_LENGTH);
	artemis_stream_setbuffer(&txstream, module.txbuffer, K9LX_BUFFER_LENGTH);


	//artemis_i2c_t *i2c = &module.i2c;


	uint32_t id0;
	uint32_t id1;

	/** Retrieve Cust_ID0 */
	//artemis_stream_put(&txstream, K9LX_MTP_CUST_ID0);


	//artemis_i2c_send(i2c, true, &txstream);



	/** @todo Add fail-out mechanism */
	//while(!module_k9lx_read_status());
	//
	//artemis_i2c_receive(i2c, true, &rxstream, 3);


	//module_k9lx_read_with_status(i2c, &rxstream, 3, 10);


	uint8_t temp;

	artemis_stream_get(&rxstream, &temp);
	id0 = temp << 8;
	artemis_stream_get(&rxstream, &temp);
	id0 |= temp;

	/** Retrieve Cust_ID1 */
	//artemis_stream_put(&txstream, K9LX_MTP_CUST_ID1);

	//artemis_i2c_send(i2c, true, &txstream);


	/** @todo Add fail-out mechanism */
	//while(!module_k9lx_read_status());
	//
	//artemis_i2c_receive(i2c, true, &rxstream, 3);


	//module_k9lx_read_with_status(i2c, &rxstream, 3, 10);

	artemis_stream_get(&rxstream, &temp);
	id1 = temp << 8;
	artemis_stream_get(&rxstream, &temp);
	id1 |= temp;

	/** Create Product Code */
	return ((id1 << 16) | id0 );
}

//static int32_t module_k9lx_read_with_status(artemis_i2c_t *i2c, artemis_stream_t *rxstream, uint32_t numBytes, uint32_t attempts)
//{
//	int32_t result = -1;
//	uint8_t temp;
//
//	do{
//		artemis_stream_reset(rxstream);
//		artemis_i2c_receive(i2c, true, rxstream, numBytes);
//		artemis_stream_get(rxstream, &temp);
//
//	}while((temp & K9LX_STATUS_BIT) && (--attempts > 0));
//
//	//printf("%u, %ul\n", temp & K9LX_STATUS_BIT, attempts);
//
//	if( !(temp & K9LX_STATUS_BIT))
//	{
//		result = 0;
//	}
//	return result;
//}



//static float module_k9lx_read_low_pressure_limit(void)
//{
//artemis_stream_t rxstream = {0};
//artemis_stream_t txstream = {0};
//artemis_stream_setbuffer(&rxstream, module.rxbuffer, K9LX_BUFFER_LENGTH);
//artemis_stream_setbuffer(&txstream, module.txbuffer, K9LX_BUFFER_LENGTH);
//
//artemis_i2c_t *i2c = &module.i2c;
//uint32_t scale1;
//uint32_t scale2;
//uint8_t temp;
//
///** Retrieve Scaling1 */
//artemis_stream_put(&txstream, K9LX_MTP_SCALING_1);
//artemis_i2c_send(i2c, true, &txstream);
//am_hal_systick_delay_us(10000);
//module_k9lx_read_with_status(i2c, &rxstream, 3, 10);
//
//artemis_stream_get(&rxstream, &temp);
//scale1 = temp << 8;
//artemis_stream_get(&rxstream, &temp);
//scale1 |= temp;
//
//
///** Reset the buffers */
//artemis_stream_reset(&rxstream);
//artemis_stream_reset(&txstream);
//
///** Retrieve Scaling2 */
//artemis_stream_put(&txstream, K9LX_MTP_SCALING_2);
//artemis_i2c_send(i2c, true, &txstream);
///** @todo Add fail-out mechanism */
////  while(!module_k9lx_read_status());
////  
////  artemis_i2c_receive(i2c, true, &rxstream, 3);
////  do{
////      artemis_stream_reset(&rxstream);
////      artemis_i2c_receive(i2c, true, &rxstream, 3);
////      artemis_stream_get(&rxstream, &temp);
////  }while((temp & K9LX_STATUS_BIT));
//  module_k9lx_read_with_status(i2c, &rxstream, 3, 10);
////  artemis_stream_get(&rxstream, &temp);
//  artemis_stream_get(&rxstream, &temp);
//  scale2 = temp << 8;
//  artemis_stream_get(&rxstream, &temp);
//  scale2 |= temp;
//  
//  
//  uint32_t pressure =  ((scale2 << 16) | scale1);
//  
//  u32_to_float_t low_p;
//  low_p.u32 = pressure;
//  
//  return low_p.f;
//}


//static float module_k9lx_read_high_pressure_limit(void)
//{
//  artemis_stream_t rxstream = {0};
//  artemis_stream_t txstream = {0};
//  artemis_stream_setbuffer(&rxstream, module.rxbuffer, K9LX_BUFFER_LENGTH);
//  artemis_stream_setbuffer(&txstream, module.txbuffer, K9LX_BUFFER_LENGTH);
//  
//  artemis_i2c_t *i2c = &module.i2c;
//  uint32_t scale3;
//  uint32_t scale4;
//  
//  /** Retrieve Scaling1 */
//  artemis_stream_put(&txstream, K9LX_MTP_SCALING_1);
//  artemis_i2c_send(i2c, true, &txstream);
//  /** @todo Add fail-out mechanism */
////  while(!module_k9lx_read_status());
//  
////  artemis_i2c_receive(i2c, true, &rxstream, 3);
//  module_k9lx_read_with_status(i2c, &rxstream, 3, 10);
//  uint8_t temp;
//  
////  artemis_stream_get(&rxstream, &temp);
//  artemis_stream_get(&rxstream, &temp);
//  scale3 = temp << 8;
//  artemis_stream_get(&rxstream, &temp);
//  scale3 |= temp;
//  
//  artemis_stream_reset(&rxstream);
//  artemis_stream_reset(&txstream);
//  
//  /** Retrieve Scaling2 */
//  artemis_stream_put(&txstream, K9LX_MTP_SCALING_2);
//  artemis_i2c_send(i2c, true, &txstream);
//  /** @todo Add fail-out mechanism */
////  while(!module_k9lx_read_status());
//  
////  artemis_i2c_receive(i2c, true, &rxstream, 3);
//  module_k9lx_read_with_status(i2c, &rxstream, 3, 10);
//  
////  artemis_stream_get(&rxstream, &temp);
//  artemis_stream_get(&rxstream, &temp);
//  scale4 = temp << 8;
//  artemis_stream_get(&rxstream, &temp);
//  scale4 |= temp;
//  
//  
//  uint32_t pressure =  ((scale4 << 16) | scale3);
//  
//  u32_to_float_t high_p;
//  high_p.u32 = pressure;
//  
//  return high_p.f;
//  
//}

static void module_k9lx_convert_memory_manufacturer(uint8_t *data, module_manufacturer_t *m)
{
	uint16_t scale0;
	/** Read the Scaling0 Bytes */
	scale0 = (uint16_t) *data << 8;
	data++;
	scale0 |= *data;

	uint16_t temp2;
	temp2 = scale0 & 0xF800;
	temp2 = temp2 >> 11;
	temp2 += 2010;
	m->year = temp2;
	m->month = (scale0 & 0x0780) >> 7;
	m->day = (scale0 &  0x007C) >> 2;
	m->mode = (eK9LX_PMode_t) (scale0 & 0x0003);
}

static float module_k9lx_convert_memory_pressure_value(uint8_t *data)
{

	uint32_t pressure = (uint32_t) *data++ << 24;
	pressure |= (*data++ << 16);
	pressure |= (*data++ << 8);
	pressure |= (*data);

	union Data {
		float f;
		uint32_t u32;
	};

	union Data p;
	
	p.u32 = pressure;

	return p.f;
}

static void module_k9lx_convert_memory_pressure( uint8_t *data, module_scaling_t *scaling)
{

	/** Convert the low pressure scaling */
	scaling->low = module_k9lx_convert_memory_pressure_value(data);
	data += 4;
	/** Convert the low pressure scaling */
	scaling->high = module_k9lx_convert_memory_pressure_value(data);
	/** Calculate diff */
	scaling->diff = scaling->high - scaling->low;
}

static void module_k9lx_read_memory_pressure(module_scaling_t *scaling)
{
	/** Prep for I2C messages */
	artemis_stream_t rxstream = {0};
	artemis_stream_t txstream = {0};
	artemis_stream_setbuffer(&rxstream, module.rxbuffer, K9LX_BUFFER_LENGTH);
	artemis_stream_setbuffer(&txstream, module.txbuffer, K9LX_BUFFER_LENGTH);


	//artemis_i2c_t *i2c = &module.i2c;

	/** Read low values */
	//artemis_stream_put(&txstream, K9LX_MTP_SCALING_1);


	//artemis_i2c_send(i2c, true, &txstream);


	am_hal_systick_delay_us(8000);


	//module_k9lx_read_with_status(i2c, &rxstream, 3, 20);

	uint8_t data[4];
	uint8_t *pData = &data[0];
	artemis_stream_read(&rxstream, pData, 2);
	pData += 2;
	// 

	artemis_stream_reset(&rxstream);
	artemis_stream_reset(&txstream);
	//artemis_stream_put(&txstream, K9LX_MTP_SCALING_2);


	//artemis_i2c_send(i2c, true, &txstream);


	am_hal_systick_delay_us(8000);

	//module_k9lx_read_with_status(i2c, &rxstream, 3, 20);


	artemis_stream_read(&rxstream, pData, 2);
	scaling->low = module_k9lx_convert_memory_pressure_value(data);

	/** Read high values */
	artemis_stream_reset(&rxstream);
	artemis_stream_reset(&txstream);
	//artemis_stream_put(&txstream, K9LX_MTP_SCALING_3);

	//artemis_i2c_send(i2c, true, &txstream);

	am_hal_systick_delay_us(8000);
	

	//module_k9lx_read_with_status(i2c, &rxstream, 3, 20);

	//uint8_t data[4];
	pData = &data[0];
	artemis_stream_read(&rxstream, pData, 2);
	pData += 2;

	// 
	artemis_stream_reset(&rxstream);
	artemis_stream_reset(&txstream);
	//artemis_stream_put(&txstream, K9LX_MTP_SCALING_4);

	//artemis_i2c_send(i2c, true, &txstream);

	am_hal_systick_delay_us(8000);

	//module_k9lx_read_with_status(i2c, &rxstream, 3, 20);

	artemis_stream_read(&rxstream, pData, 2);
	scaling->high = module_k9lx_convert_memory_pressure_value(data);
	scaling->diff = scaling->high - scaling->low;
}

static int8_t module_k9lx_data_integrity (uint8_t *Data, uint8_t len){

	/*	check received data's Function's code
	 *	7th bit of second byte will tell the error has been received
	 *	third byte would be the error code, follow the MODBUS communication protocol v3.7
	 *	check the CRC on the received bytes
	 * 
	 */

	// copy the Data into the local buffer
	uint8_t lBuf[K9LX_BUFFER_LENGTH] = {0};
	uint8_t crc_h, crc_l = 0;

	for (uint8_t i=0; i<len; i++){
		lBuf[i] = Data[i];
	}

	// check the function code error bit (7th bit)
	if (K9LX_RECV_ERROR & lBuf[1]){
		// TODO : error has been occured, handle it further with the error code on third-byte
		return -1;
	}
	else {
		// check the CRC16, send only the useful bytes, last two bytes are CRC-bytes
		module_k9lx_crc16 (&crc_h, &crc_l, lBuf, len-2);
		if (crc_l == lBuf[len-2] && crc_h == lBuf[len-1]) {
			// received data is correct
			return 0;
		}
		else {
			// TODO: handle the error code
			return -1;
		}
	}
	// unknown error
	return -2;
}

static int8_t module_k9lx_read_reg(uint8_t port, uint16_t reg_add, uint8_t reg_num, uint8_t *pData)
{
	/** Prep for MAX SPI messages */
	uint8_t cmd[CMD_LENGTH] = {0};
	uint8_t rxData[K9LX_BUFFER_LENGTH] = {0};
	uint8_t rxLen = 0;
	uint8_t crc_h, crc_l = 0;

	cmd[0] = K9LX_ADDR;
	cmd[1] = K9LX_READ_REG_CMD;
	cmd[2] = (reg_add >> 8) & 0xFF;
	cmd[3] = reg_add & 0xFF;
	cmd[4] = 0x00;
	cmd[5] = reg_num ; // read number of registers

	/* calculate CRC16 */ 
	module_k9lx_crc16 (&crc_h, &crc_l, cmd, 6);

	/* MODBUS */
	cmd[6] = crc_l;
	cmd[7] = crc_h;

	artemis_max14830_UART_Write(port, cmd, CMD_LENGTH);

	// wait for 100us , or even longer 
	am_hal_systick_delay_us(100);

	artemis_max14830_UART_Read(port, rxData, &rxLen);

	// check data integrity 
	int8_t ret = module_k9lx_data_integrity (rxData,rxLen);

	if (ret == 0 && rxLen > 0){
		//am_util_stdio_printf ("Received Successfully RET (%d) at Keller = ", ret);
		for(uint8_t i=0; i<rxLen-2-3; i++){
			//am_util_stdio_printf ("0x%02X ", rxData[i]);
			//am_util_stdio_printf ("%d ", rxData[i]);
			pData[i] = rxData[3+i];
		}
	}
	else {
		am_util_stdio_printf ("Received ERROR (%d) at keller \n", ret);
	}
	//am_util_stdio_printf ("\n");

	return ret;
}

//static void module_k9lx_read_conf(uint8_t port)
void module_k9lx_read_conf(uint8_t port)
{
	uint8_t firmware[4] = {0};
	uint8_t serial[4] = {0};
	uint32_t serial_number = 0;

	int8_t ret = 0;

	// Get the Firmware version : 5.20.12.28
	//ARTEMIS_DEBUG_PRINTF("Firmware Version : ");
	ret = module_k9lx_read_reg(port, K9LX_FIRM_VER0, 2, firmware);
	//if (ret == 0) {
	//	for (uint8_t i=0; i<4; i++){
	//		am_util_stdio_printf ("%d.", firmware[i]);
	//	}
	//}
	//am_util_delay_ms(200);

	// Get the Serial number : ? 
	//ARTEMIS_DEBUG_PRINTF("Serial Number : ");
	ret = module_k9lx_read_reg(port, K9LX_SER_NUM_H, 2, serial);
	//if (ret == 0) {
	//	for (uint8_t i=0; i<2; i++){
	//		serial_number |= (serial[i] << (8*3-i));
	//	}
	//	am_util_stdio_printf ("%u", serial_number);
	//}

	//am_util_delay_ms(1000);

	//am_util_delay_ms(100);
	//module_k9lx_read_reg(port, K9LX_FIRM_VER1, 1, firmware1);

}

//static void module_k9lx_read_manufacturer(module_manufacturer_t *manufacturer)
//{
//    /** Read the Scaling0 Data */
//  artemis_stream_t rxstream = {0};
//  artemis_stream_t txstream = {0};;
//  artemis_stream_setbuffer(&rxstream, module.rxbuffer, K9LX_BUFFER_LENGTH);
//  artemis_stream_setbuffer(&txstream, module.txbuffer, K9LX_BUFFER_LENGTH);
//  
//  artemis_i2c_t *i2c = &module.i2c;
//  uint16_t scale0;
//
//  /** Retrieve Scaling1 */
//  artemis_stream_put(&txstream, K9LX_MTP_SCALING_0);
//  artemis_i2c_send(i2c, true, &txstream);
//  /** @todo Add fail-out mechanism */
//   am_hal_systick_delay_us(10000);
//  module_k9lx_read_with_status(i2c, &rxstream, 3, 10);
//  uint8_t temp;
//  
////  /** Read but skip the status byte */
////  artemis_stream_get(&rxstream, &temp);
//  
//  /** Read the Scaling0 Bytes */
//  artemis_stream_get(&rxstream, &temp);
//  scale0 = temp << 8;
//  artemis_stream_get(&rxstream, &temp);
//  scale0 |= temp;
//  
//  uint16_t temp2;
//  temp2 = scale0 & 0xF800;
//  temp2 = temp2 >> 11;
//  temp2 += 2010;
//  manufacturer->year = temp2;
////  manufacturer->year = ((scale0 & 0xF800) >> 10 + 2010);
//  manufacturer->month = (scale0 & 0x0780) >> 7;
//  manufacturer->day = (scale0 &  0x007C) >> 2;
//  manufacturer->mode = (K9LX_PMode_t) (scale0 & 0x0003);
//  
//  
//  manufacturer->custom_id = module_k9lx_read_unique_product_code();
//}
